#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{pgfgantt}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\usepackage{a4wide}
\usepackage[show]{ed}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 4cm
\topmargin 3cm
\rightmargin 4cm
\bottommargin 3cm
\headheight 3cm
\headsep 3cm
\footskip 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
MathSemantifier - a Notation-based Semantification Study
\end_layout

\begin_layout Author
Toloaca Ion
\begin_inset Newline newline
\end_inset

Supervisor: Michael Kohlhase
\begin_inset Newline newline
\end_inset

Jacobs University Bremen
\end_layout

\begin_layout Abstract
Mathematical formulae are a highly ambiguous content for which typesetting
 systems as LaTeX store only the representation.
 MathSemantifier is an open-source notation-based mathematical formula semantifi
cation system that attempts to tackle the problem of ambiguity in mathematical
 documents and produce knowledge-rich equivalents.
 The system extracts formulae (from formats such as LaTeX or MathML) and
 produces content-rich results (sTeX or Content MathML) that contain no
 semantic ambiguity.
 The disambiguation is achieved by matching the input formulae against a
 known database of notation definitions, which is aggregated into a Context
 Free Grammar.
 This paper outlines an implementation of MathSemantifier that focuses on
 helping researchers in semantifying their works, and the ultimate goal
 being a scalable implementation that would need next to no help from a
 human, and, therefore, could be used to semantify large collections of
 mathematical papers such as arXiV 
\begin_inset CommandInset citation
LatexCommand citep
key "ArXiv"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The scientific community produces a large number of mathematical papers
 (approximately 120 thousand new papers per year), which raises the importance
 of machine based processing of such documents.
 Unfortunately, the most popular formats in which these papers are found
 (for instance, LaTeX) do not contain much information that would allow
 the computers to infer the complex knowledge graph behind each paper.
 Since, at this point, changing these formats is not practically possible,
 the other solution is to add a semantic flavor to the existing documents
 by translating them into a more suitable format, for instance, Content
 MathML.
\end_layout

\begin_layout Subsection
History and Motivation
\end_layout

\begin_layout Standard
As a system as complex as the current scientific community was created,
 it went through a series of evolutions in the attempt to introduce the
 best method of writing scientific documents.
 This process was highly influenced by the invention and spreading of the
 internet.
 Scientists understood the necessity of a standard that could help them
 write and exchange their findings in an efficient way.
 A lot of effort has gone into translating books into digital documents.
 
\end_layout

\begin_layout Standard
Now, scientists have found ways to represent their knowledge in a machine
 comprehensible manner, some of which are Content MathML and OMDoc 
\begin_inset CommandInset citation
LatexCommand citep
key "OMDOC"

\end_inset

.
 These new methods do not directly store the representation of the documents.
 Instead, what is actually stored is the knowledge graph hidden behind the
 ambiguity of the representation.
 Naturally, these documents can be used to also generate a human readable
 format, examples being Presentation MathML and LaTeX.
\end_layout

\begin_layout Standard
As previously mentioned, a lot of effort went into translating books into
 digital documents.
 Since the year of 1850, there have been produced approximately 3.5 million
 papers, and approximately 120 thousand new papers are written every year.
 Now, when all these digital documents need to be converted to these semantic
 representation, doing it by hand is not just unreasonable, but straight
 out impossible.
\end_layout

\begin_layout Standard
The next step in this evolution is translating digital documents into improved
 digital documents, that the computers can actually understand and not just
 store.
 This next step can only happen if a new, relatively painless, way of transition
 appears.
 As soon as the ease of transition and the benefits from doing it outweigh
 the difficulties associated with it, the scientific community will open
 the door into the world where computers can actively help researchers with
 more than just symbolic searches.
\end_layout

\begin_layout Subsection
Content MathML and Presentation MathML
\end_layout

\begin_layout Standard
The two main formats this paper is focusing on are Content MathML (CMML)
 and Presentation MathML (PMML) 
\begin_inset CommandInset citation
LatexCommand citep
key "W3C03"

\end_inset

.
\end_layout

\begin_layout Standard
PMML is used to describe the layout and structure of mathematical notations.
 PMML elements construct the basic kinds of symbols and expression-building
 structures present in traditional mathematical notations, containing also
 enough information for good renderings.
 The last part is exactly the motivation as to why MathML alone is not enough
 - because it only suggests specific ways of renderings, but does not require
 anything.
 
\end_layout

\begin_layout Standard
CMML, on the other hand, is used to provide an explicit encoding of the
 underlying mathematical meaning of mathematical expressions.
 This fact is important in this context because this implies that CMML contains
 no ambiguity, so, by choosing the final product to be CMML, it is indeed
 possible to achieve meaningful semantification.
 For example, considered 
\begin_inset Quotes eld
\end_inset

H multiplied by e
\begin_inset Quotes erd
\end_inset

.
 It can be often seen to be written as 
\begin_inset Formula $H$
\end_inset


\begin_inset Formula $e$
\end_inset

 in mathematics, however, this can be interpreted also as 
\begin_inset Formula $H$
\end_inset

 applied to 
\begin_inset Formula $e$
\end_inset

 in the context of lambda calculus, as well as a chemical.
\end_layout

\begin_layout Standard
An example of PMML and CMML code for the expression 
\begin_inset Formula $x+y$
\end_inset

 is provided in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:1}
\end_layout

\end_inset

.
 Note how the 
\series bold
mrow
\series default
 tag is used to delimit nested expressions, while the 
\series bold
mo
\series default
 tag indicate mathematical objects (such as arithmetic operators) and 
\series bold
mi
\series default
 is used for variables and similar objects.
 This provides a clear structured format, that is parsed by MathSemantifier.
 In particular, PMML is such a small and convenient language that even building
 a parser for it as a part of MathSemantifier is certainly reasonable.
\end_layout

\begin_layout Standard
In the CMML part of the example, the 
\series bold
apply
\series default
 tag is semantically the application of its first element (the arithmetic
 plus) on two identifiers 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, which altogether means simply 
\begin_inset Formula $x+y$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 2.25cm
\end_inset


\begin_inset Graphics
	filename pmmlANDcmml.png
	width 12cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
PMML and CMML 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:1}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An important part of CMML is that all notations (like the arithmetic plus
 notations used in the example above), contain specifications of how these
 should be rendered into PMML, so the conversion is not a problem.
\end_layout

\begin_layout Subsection
Ambiguity in Mathematical Documents
\end_layout

\begin_layout Standard
An important concept necessary in order to understand why semantification
 is a complex process is ambiguity.
 Mathematical documents are not a simple collection of symbols.
 The main use of these documents emerges only when the knowledge graph of
 a document is accessible.
 However, humans tend to be lazy in writing down the whole graph, but instead
 rely on implicit human knowledge to decipher these documents.
 This is where ambiguity comes into play, when the author relies on the
 ability of the human to use the context of document in order to pinpoint
 the actual meaning an expression.
 Ambiguities can be largely divided into two: structural and idiomatic ambiguiti
es.
\end_layout

\begin_layout Subsubsection
Structural Ambiguities
\end_layout

\begin_layout Standard
A simple example that demonstrates the concept of structural ambiguities
 can be 
\begin_inset Formula $f(a(b))$
\end_inset

.
 It can mean one of the following:
\end_layout

\begin_layout Enumerate
Application of function 
\begin_inset Formula $f$
\end_inset

 to 
\begin_inset Formula $a$
\end_inset

 times 
\begin_inset Formula $b$
\end_inset


\end_layout

\begin_layout Enumerate
Application of function 
\begin_inset Formula $f$
\end_inset

 to the application of 
\begin_inset Formula $a$
\end_inset

 to 
\begin_inset Formula $b$
\end_inset


\end_layout

\begin_layout Enumerate
Multiplication of 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset


\end_layout

\begin_layout Enumerate
Multiplication of 
\begin_inset Formula $f$
\end_inset

 and the application of 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset


\end_layout

\begin_layout Standard
Note how such a simple example with just three identifiers has at three
 different possible interpretations.
 It is easy to notice that the number of readings has an exponential complexity
 in the length of the expression.
 For instance, the expression above has 
\begin_inset Formula $2^{n-1}$
\end_inset

 readings, where 
\begin_inset Formula $n$
\end_inset

 is the number of identifiers, which is because we can considered each applicati
on as a multiplication too.
\end_layout

\begin_layout Standard
The concept above can be generalized as structural ambiguities being associated
 to different readings generated from different parse trees.
 This means that the document may provide some direct clue about what parse
 tree is the best, and the readings can be characterized by parse trees.
\end_layout

\begin_layout Subsubsection
Idiomatic Ambiguities
\end_layout

\begin_layout Standard
Contrary to structural ambiguities, idiomatic ambiguities are not due to
 different parse trees.
 Given one single parse tree, some formulae allow for multiple readings.
 A standard example would be 
\begin_inset Formula $B_{n}$
\end_inset

.
 This could be:
\end_layout

\begin_layout Enumerate
The sequence of Bernoulli numbers
\end_layout

\begin_layout Enumerate
A user defined sequence
\end_layout

\begin_layout Enumerate
The vertex of one of a series of geometric objects
\end_layout

\begin_layout Standard
In other words, the same sequence of symbols, associated with the same parse
 tree can lead to multiple readings.
 The only feasible way at the moment of solving such ambiguities is having
 a large notation database and ultimately asking the user to choose from
 a list of possible readings.
 This is exactly how MathSemantifier works, which means that the final product
 is expect to excel at solving such tasks.
\end_layout

\begin_layout Subsection
Extracting Semantics from Mathematical Documents
\end_layout

\begin_layout Standard
Ambiguity is the problem, so, now, a solution for it is required.
 Let us recall the example from the previous section 
\begin_inset Formula $f(a(b))$
\end_inset

.
 The first interpretation of the expression a human reader is likely to
 come up with is the application of 
\begin_inset Formula $f$
\end_inset

 to the application of 
\begin_inset Formula $a$
\end_inset

 to 
\begin_inset Formula $b$
\end_inset

.
 Moreover, the other readings may take the human reader by surprise, as
 he or she would assume that the first reading is the correct one.
 
\end_layout

\begin_layout Standard
Let us look into why this happens.
 First of all, 
\begin_inset Formula $f$
\end_inset

 is a symbol humans usually use for functions, moreover, the brackets around
 
\begin_inset Formula $a(b)$
\end_inset

 could be omitted if it were a multiplication rather than an application.
 Next, 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are usually used for variables, but then again the brackets are useless
 if it is a multiplication.
 To sum up, the human throws away meanings that would imply useless work
 or usage of symbols in an unusual way.
 Imagine asking a mathematician which of the expressions is more natural,
 
\begin_inset Formula $fa$
\end_inset

 or 
\begin_inset Formula $ab$
\end_inset

, or, to be even more extreme, 
\begin_inset Quotes eld
\end_inset

Let 
\begin_inset Formula $\epsilon>0$
\end_inset


\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Let 
\begin_inset Formula $\epsilon<0$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 All of these can be translated to heuristics that MathSemantifier can use
 to improve its results, or otherwise said, minimize the amount of work
 the human has to do by restricting the possible meanings as much as possible.
\end_layout

\begin_layout Standard
Up until now, different heuristics used were discussed.
 However, mathematics has better means of finding the one true meaning of
 the document.
 Imagine the formula 
\begin_inset Formula $a=b$
\end_inset

.
 As a human, we can deduce it may mean that some two objects are equal.
 We still have absolutely no understanding of what those objects are, and
 we just assume 
\begin_inset Formula $=$
\end_inset

 works as a relation on any 2 objects of the same type.
\end_layout

\begin_layout Standard
Now let's add a bit to the formula 
\begin_inset Formula $(a=b)\wedge(b=3)$
\end_inset

.
 At this point, we deduce that 
\begin_inset Formula $a=3$
\end_inset

, and 
\begin_inset Formula $=$
\end_inset

 is a relation of numbers by applying First Order Logic to the expression.
 Notice how more context reduced the ambiguity of the previous expression.
 Also, notice how we naturally assume First Order Logic is applicable to
 this situation.
 Notice also that we are not using just heuristics, but rather we are applying
 a deterministic approach to find out which meanings are impossible.
\end_layout

\begin_layout Standard
Let's get to a more interesting example 
\begin_inset Formula $f(a+b)$
\end_inset

.
 Normally, we would assume this is a function applied to 
\begin_inset Formula $a+b$
\end_inset

, but nothing in this context can help us decide against 
\begin_inset Formula $f$
\end_inset

 multiplied by 
\begin_inset Formula $a+b$
\end_inset

.
 Adding an expression like 
\begin_inset Formula $f:\mbox{R\rightarrow R}$
\end_inset

 would certainly help to reason against the second interpretation, because
 it does not typecheck.
\end_layout

\begin_layout Standard
To sum up, humans read mathematical documents bit by bit and throw away
 impossible interpretations until there is, hopefully, only one left.
 In doing so, they mainly apply two strategies - heuristics and proof by
 contradiction.
 This proposal explores the possibility of MathSemantifier doing the same
 to some extent.
 
\end_layout

\begin_layout Subsection
MathSemantifier in the Context of Disambiguation
\end_layout

\begin_layout Standard
In the endeavour of extracting semantics from mathematical documents MathSemanti
fier uses its notation database in order to attempt to explore the space
 of all possible readings, and the to throw away some using heuristics,
 ultimately letting the user decide which reading is the best.
\end_layout

\begin_layout Standard
This makes clear the parts the final product excels at, but also the main
 challenges related to that.
\end_layout

\begin_layout Standard
Regarding the good parts:
\end_layout

\begin_layout Itemize
Solving both structural and idiomatic ambiguities by exploring the space
 of all readings
\end_layout

\begin_layout Itemize
Notation addition can be easily added to the system, since the Context Free
 Grammar used is generated automatically 
\end_layout

\begin_layout Itemize
Enhanced overall user experience when writing or semantifying existing mathemati
cal documents by creating a dynamic, adaptive system by means of the above
 mentioned strengths
\end_layout

\begin_layout Standard
The main challenges are:
\end_layout

\begin_layout Itemize
Scalability in the context of such a system translates into finding the
 best ways to generate as few useless parse trees as possible
\end_layout

\begin_layout Itemize
Compiling a notation database into a Context Free Grammar when including
 multiple notation archives simultaneously 
\end_layout

\begin_layout Itemize
The response time of a query to the system is a big issue, since, as mentioned
 before, everything related to ambiguities has an exponential time complexity.
 Finding a balance between exploring the space of all readings enough in
 order to find meaningful results while keeping the response time low is
 a very difficult challenge.
\end_layout

\begin_layout Standard
The rest of this paper demonstrates in detail how MathSemantifier harnesses
 its strengths and solves or avoids the challenges described.
\end_layout

\begin_layout Section
State of the Art
\end_layout

\begin_layout Subsection
Semantification
\end_layout

\begin_layout Standard
Nowadays extracting the semantics of mathematical documents is regarded
 as an interesting field, however the number of researchers in it is limited.
 This is caused by several domain specific problems.
\end_layout

\begin_layout Standard
First of all, mathematics is usually represented in a format where it mixed
 with natural language.
 Research on extracting mathematical expressions from such contexts has
 not been incredibly successful so far.
 Another important problem is the lack of a well prepared set of data.
 This kind of data could be used for Machine Learning applications as training
 data, or simply as test data for complex systems.
 As software that has not been tested cannot be called particularly useful,
 this poses a great problem.
\end_layout

\begin_layout Subsubsection
Restricted Natural Language
\end_layout

\begin_layout Standard
There are multiple projects that try to use a subset of the natural language
 that is still not that ambiguous but allows for intuitive document creation.
 Such projects are FMathL 
\begin_inset CommandInset citation
LatexCommand citep
key "NS10"

\end_inset

, MathLang 
\begin_inset CommandInset citation
LatexCommand citep
key "KMW04"

\end_inset

, MathNat 
\begin_inset CommandInset citation
LatexCommand citep
key "HR10"

\end_inset

 and Naproche 
\begin_inset CommandInset citation
LatexCommand citep
key "CKS11"

\end_inset

.
\end_layout

\begin_layout Standard
Most such approaches try to analyze the context free parts of mathematical
 expressions.
 We will go into more detail about Context Free Grammar applications in
 semantification in the next sections.
 It is worthy to note though that most such projects are not satisfied by
 commonly found grammar engines, and some, like FMathL, are developing their
 own specialized parsers.
 This paper does not outline custom parsers, however, if further work is
 to be done on the subject, implementing heuristics as to reduce the disambiguat
ion choice list could require at some point a similar approach.
\end_layout

\begin_layout Subsubsection
Format Conversions
\end_layout

\begin_layout Standard
Mathematical documents in their majority are written in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
TeX/
\backslash
LaTeX
\end_layout

\end_inset

, but for storage and processing purposes converting them to an XML representati
on is a good idea.
 Large scale mathematical document archives such as 
\begin_inset Formula $arXMLiv$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "SKG"

\end_inset

 are using the LaTeXML 
\begin_inset CommandInset citation
LatexCommand citep
key "Bru07"

\end_inset

 converter to produce MathML and OpenMath.
\end_layout

\begin_layout Standard
LaTeXML can actually already produce Content MathML, however the result
 produced in such a way from a knowledge poor setting contains only one
 of the possible readings, and, therefore, is not satisfactory from a semantic
 point of view as it not need satisfy the actual semantics of the document.
 Enhancing LaTeXML's ability of converting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

 into knowledge rich XML format variations by exploring the space of possible
 readings is one of the main goal of this proposal.
\end_layout

\begin_layout Subsection
Using Grammars for Semantification
\end_layout

\begin_layout Subsubsection
Combinatory Categorial Grammars
\end_layout

\begin_layout Standard
The MSc Thesis of Deyan Ginev 
\begin_inset CommandInset citation
LatexCommand citep
key "DEYAN11"

\end_inset

 studies a similar approach that uses Combinatory Categorial Grammars as
 a part of a larger analysis pipeline that is applied to handpicked set
 of mathematical texts.
 The results show a close to perfect recall rate with a low degree of ambiguity.
 
\end_layout

\begin_layout Standard
This approach, however, uses a manually crafted grammar as opposed to the
 generated grammar used by MathSemantifier.
 While writing a grammar by hand can lead to good results as mentioned above,
 this approach does not scale, since it is hard to find someone who will
 write such grammars every time a new notation is needed.
 Notations, on the other hand, are much faster and easier to write.
 In other words, scalability and extensibility are the reasons behind MathSemant
ifier.
\end_layout

\begin_layout Subsubsection
S-graph grammars
\end_layout

\begin_layout Standard
The research of Alexander Koller of University of Potsdam exhibits an interestin
g way of utilizing grammars for semantic construction.
 S-graph grammars 
\begin_inset CommandInset citation
LatexCommand citep
key "KOLLSG"

\end_inset

 constitute a new grammar formalism for computing graph based semantic represent
ations.
 What distinguishes this line of research from the common data-driven systems
 trained for such purposes is that S-graph grammars use graphs as semantic
 representations in a way that is consistent with more classical views on
 semantic construction.
\end_layout

\begin_layout Standard
S-graph grammars are introduced as a synchronous grammar formalism that
 describes relations between strings and graphs, which can be used for a
 graph based compositional semantic construction, which is essentially what
 this paper outlines in simpler terms - using Context Free Grammars.
\end_layout

\begin_layout Subsubsection
Marpa Grammar Engine
\end_layout

\begin_layout Standard
As the idea of the proposal is to use a Grammar Engine, we need to introduce
 a concrete solution.
 Text parsing using Context Free Grammars is quite popular, and, therefore,
 there is quite a number of solutions, which can, however, make the choice
 of the best grammar engine for a particular purpose difficult.
 After comparing several such tools, the conclusion reached was that the
 Marpa Grammar Engine 
\begin_inset CommandInset citation
LatexCommand citep
key "Jeff"

\end_inset

 stands out as a flexible, powerful and efficient tool suited for the purpose
 of semantification.
\end_layout

\begin_layout Standard
To understand better the claim about efficiency, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:mcomp}
\end_layout

\end_inset

 provides a comparison between multiple regex parsers and Marpa made by
 the creator of Marpa is provided.
\begin_inset CommandInset citation
LatexCommand citep
key "marpaComparison"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename marpaComparison.png
	width 16cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Marpa Parser - Comparison with other Parsers 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:mcomp}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results are presented in executions per second.
 We can see that standard solutions may be faster for a small nesting level,
 but they go quadratic as it rises.
\end_layout

\begin_layout Standard
Another important point is that Marpa Grammar Engine has a quite simple
 interface, allowing for extensive manipulations during the parsing process.
 Each rules can be given an 
\begin_inset Quotes eld
\end_inset

Action
\begin_inset Quotes erd
\end_inset

 - a Perl routine - that can define what the engine is supposed to do when
 the rules is used.
 
\end_layout

\begin_layout Standard
As it was mentioned in the previous sections, the grammar generated is highly
 ambiguous, and the Marpa Engine allows for ambiguous grammar of any kind
 that are required for this application.
\end_layout

\begin_layout Subsection
Extracting Formulae from Mathematical Documents
\end_layout

\begin_layout Standard
As MathSemantifier as described in this paper need not be restricted to
 processing just MathML formulae, but also mathematical documents written
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

, a method of extracting MathML formulae from mathematical documents needs
 to be provided.
 A simple way of achieving that would be by using the same method as MathWebSear
ch 
\begin_inset CommandInset citation
LatexCommand citep
key "MWS12"

\end_inset

 is using in order to extract MathML formulae from documents containing
 MathML formulae and other information.
 The structure of MWS is shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:mws}
\end_layout

\end_inset

.
 MathWebSearch accepts MwsHarvest 
\begin_inset CommandInset citation
LatexCommand citep
key "MWSHarvest"

\end_inset

 as from the crawler as seen in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:mws}
\end_layout

\end_inset

.
 These harvests are in Presentation MathML, therefore perfectly suited for
 this application.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 1.5cm
\end_inset


\begin_inset Graphics
	filename mwsStructure.png
	width 13cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
MathWebSearch Architecture 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:mws}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Preliminaries
\end_layout

\begin_layout Subsection
The Notation Database of MMT
\end_layout

\begin_layout Standard
MathSemantifier uses a Notation Database to create the grammar it uses.
 Therefore, it needs to be explained where those notations come from.
 MMT 
\begin_inset CommandInset citation
LatexCommand citep
key "MMT"

\end_inset

 (Module system for Mathematical Theories) is a language developed as a
 scalable representation and interchange language for mathematical knowledge.
 It permits natural representations of the syntax and semantics of virtually
 all declarative languages.
 The decisive factor about MMT is that there is already a large database
 of notations written in sTeX, which is transformed and stored in MMT in
 an original format that MathSemantifier is processing in order to generate
 a Context Free Grammar.
\end_layout

\begin_layout Standard
SMGloM 
\begin_inset CommandInset citation
LatexCommand citep
key "SMGLOM"

\end_inset

 is a part of the notation database of MMT that is especially relevant to
 the MathSemantifier.
 It contains notations from vastly different topics such as:
\end_layout

\begin_layout Itemize
Algebra
\end_layout

\begin_layout Itemize
Calculus
\end_layout

\begin_layout Itemize
Geometry
\end_layout

\begin_layout Itemize
Graphs
\end_layout

\begin_layout Itemize
Number fields
\end_layout

\begin_layout Itemize
Topology
\end_layout

\begin_layout Itemize
Set Theory
\end_layout

\begin_layout Subsection
MMT Notation Storage Format
\end_layout

\begin_layout Standard
The original format that MMT uses to store the notations is of high relevance,
 since it the raw material from which the Context Free Grammar is generated.
 The format consists of a Scala 
\series bold
case class 
\series default
tree.
 Several examples are provided in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:2}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 3cm
\end_inset


\begin_inset Graphics
	filename marker.png
	width 10cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
MMT Notation Markers 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:2}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since there are about 40 types of different Markers, the tree above is meant
 to simply give an idea of the structure, rather than explain it fully.
 The 
\series bold
Marker
\series default
 class is the tree of all possible notation components.
 The most basic types of Markers include 
\series bold
Presentation Markers 
\series default
and 
\series bold
Argument Markers.

\series default
 They have a great diversity of subtypes.
 
\series bold
Simple Argument 
\series default
is used for single arguments, while 
\series bold
Sequence Argument 
\series default
is a placeholder for a sequence with a specified delimiter.
 The most basic example of a sequence argument is, if considering the example
 
\begin_inset Formula $2+3+5$
\end_inset

, the sequence 
\begin_inset Formula $2,3,5$
\end_inset

 and the delimiter 
\begin_inset Formula $+$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Presentation Markers 
\series default
have yet another purpose of simulating the PMML structure.
 
\series bold
Group Marker 
\series default
stands for the 
\series bold
mrow 
\series default
MathML tag, 
\series bold
Fraction Marker 
\series default
- for 
\series bold
mfrac 
\series default
and so on.
 MMT has Markers for every possible MathML tag, which goes to explain the
 total number of Markers to an extent.
\end_layout

\begin_layout Subsection
LaTeXML Pre-processing
\end_layout

\begin_layout Standard
Since sTeX, as an extension of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

, is just as complex to parse, MMT uses LaTeXML in order to convert sTeX
 to OMDoc 
\begin_inset CommandInset citation
LatexCommand citep
key "OMDOC"

\end_inset

.
 OMDoc is then processed and stored in MMT.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:3}
\end_layout

\end_inset

 contains an example of the arithmetic plus notation written in sTeX and
 the equivalent in MathML.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename sTeXtoOMDOC.png
	width 16cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
sTeX to OMDoc conversion 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:3}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Marpa Context Free Grammar Parser
\end_layout

\begin_layout Standard

\series bold
MathSemantifier
\series default
 takes the an auto-generated CFG and input from the 
\series bold
Web UI
\series default
 (discussed in more details in further sections) in order to produce possible
 parse trees of the input.
 Marpa Grammar Engine is the proposed.
 It was already discussed above, so let us summarize the important points
 that matter for this particular application.
\end_layout

\begin_layout Standard
Marpa is 
\begin_inset CommandInset citation
LatexCommand citep
key "marpaParser"

\end_inset


\end_layout

\begin_layout Itemize
Fast - it parses grammars in linear time.
 This is critical since the size of the grammar is likely to be at least
 linear in the number of notations
\end_layout

\begin_layout Itemize
Powerful - it can parse left, right and middle recursions.
 Since it is unclear what kind of recursions can occur in generated grammars,
 and it would be a pity if the parse tree generator would need to be changed
 midway because of it, it is better to choose something that can handle
 all kinds of recursion
\end_layout

\begin_layout Itemize
Convenient - Parser generation is unrestricted and exact, all that needs
 to be provided is a CFG in BNF form.
 Also, if several alternatives may yield a parse, all of them are considered.
 This is critical, since this directly implies that it can deal with ambiguous
 grammars
\end_layout

\begin_layout Itemize
Flexibility - it provides control over the parsing process, giving out informati
on about which rules have been recognized so far and their locations.
 This is again extremely important because otherwise, once again, semantificatio
n would be simply impossible
\end_layout

\begin_layout Standard
Since the CFG is ambiguous this is the most computationally intensive part.
 The perfomance of the final product mostly depends on the efficiency of
 this step.
\end_layout

\begin_layout Standard
As a side note, Marpa does not have a Scala API, so, instead, the Perl API
 is used.
 This implies that the result parse trees need to be transported somehow
 to the core application in MMT.
 For that purpose LWP is used.
 
\begin_inset CommandInset citation
LatexCommand citep
key "LWP"

\end_inset

.
 LWP is a set of Perl modules which provide a simple and consistent API
 to the World Wide Web.
 After experimenting with the API, the conclusion was that the API is simple
 and powerful enough for the current purpose.
\end_layout

\begin_layout Section
Use Cases 
\end_layout

\begin_layout Standard
MathSemantifier has two major use cases.
 
\end_layout

\begin_layout Itemize
The user can guide the semantification of the top symbol directly, by choosing
 the correct matching range, notation and argument positions.
 
\end_layout

\begin_layout Itemize
The other option is to ask for all the possibilities and get all the semantic
 trees.
\end_layout

\begin_layout Subsection
User Guided Semantification
\end_layout

\begin_layout Standard
The user provides Presentation MathML as input to the system, then uses
 the 
\series bold
Semantify 
\series default
button to reveal a list of top level notations as shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:4}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename guided1.png
	width 13cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Top level notations 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:4}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The names of the notations are derived from the notation paths as follows:
 
\series bold
archive name
\series default
 + 
\series bold
sybmol name.

\series default
 The result is humanly readable in most cases as seen in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:4}
\end_layout

\end_inset

.
 For example, 
\series bold
natarith addition 
\series default
refers to the addition of natural numbers, 
\series bold
comparith addition 
\series default
- to the addition of complex numbers and so on.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename guided2.png
	width 9cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Argument choice 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:5a}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset

 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename guided3.png
	width 9cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Content MathML
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:5b}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Semantification
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
After determining which notation is the correct one, the user needs to make
 sure that the arguments were detected properly (see 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:5a}
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Finally, the resulting Content MathML is displayed, as shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:5b}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Semantic Tree Generation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ednote{Should I try to export the Semantic Tree in some JSON format and
 make a nice tree-like visualization?}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The easier but computationaly more expensive alternative is to simply generate
 all the possible parse trees at once and display them.
 The user simply needs to click the 
\series bold
Show Semantic Tree
\series default
 option.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename auto1.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Semantic Tree Results 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:6}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the example shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:6}
\end_layout

\end_inset

, there is a total of 72 different readings.
 This can be easily explained, since 
\series bold
Invisible Times 
\series default
and 
\series bold
Arithmetic Plus
\series default
 have each 6 different notations, and 
\series bold
Mod 
\series default
has 2.
 
\begin_inset Formula $6\cdot6\cdot2=72$
\end_inset

 explains exactly where the 
\begin_inset Formula $72$
\end_inset

 readings come from, since each notation can be combined with any other
 notation without any restrictions.
\end_layout

\begin_layout Subsubsection
Term Sharing
\end_layout

\begin_layout Standard
In order to minimize the Content MathML, the standard allows subtree sharing.
 To enable this option, the 
\series bold
Use term sharing 
\series default
checkbox should be checked.
 In that case, the terms is shared along different readings.
 This feature could be useful for an application that requires all the possible
 readings, to minimize user interaction, for instance.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Project Goals and Challenges
\end_layout

\begin_layout Standard
The main goals of the project are:
\end_layout

\begin_layout Itemize
Generating the correct set of parses efficiently and effectively
\end_layout

\begin_layout Itemize
Providing opportunities for improvement for further research in the area
\end_layout

\begin_layout Standard
The challenges on the way of achieving a way of generating dynamically the
 full set of semantic parse trees are:
\end_layout

\begin_layout Itemize
Aggregating the mathematical notation database that the MMT system into
 a CFG
\end_layout

\begin_layout Itemize
Dealing with scalability issues which are entailed by ambiguity
\end_layout

\begin_layout Itemize
The set of correct parses should be a subset of the set of generated parses
\end_layout

\begin_layout Itemize
The set of generated parses should ideally be a subset of the set of correct
 parses too
\end_layout

\begin_layout Itemize
Handle character encodings correctly
\end_layout

\begin_layout Standard
This following subsections how 
\series bold
MathSemantifier
\series default
 achieves the above goals.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[6]{Section 6}
\end_layout

\end_inset

 shows to what extent the challenges described are overcome and how.
\end_layout

\begin_layout Subsection
MathSemantifier 
\series medium
Architecture
\end_layout

\begin_layout Standard
The architecture can be roughly divided into four parts as shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:7}
\end_layout

\end_inset

.
 The components will be discussed in more details in the further subsections.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hspace{}
\length 2cm
\end_inset


\begin_inset Graphics
	filename myThesisComponents_diagram.png
	width 12cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout

\series bold
MathSemantifier
\series default
 Architecture 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:7}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Component communication
\end_layout

\begin_layout Standard
Regarding the communication between parts:
\end_layout

\begin_layout Itemize
MMT Backends and MMT Notation DB are both part of the MMT Server Application
\end_layout

\begin_layout Itemize
All the other connections are implemented using the 
\series bold
REST 
\series default
protocol, using simple 
\series bold
POST 
\series default
requests
\end_layout

\begin_layout Standard
This also implies that the all the different components do not need to run
 on one machine, especially the 
\series bold
Web UI 
\series default
and
\series bold
 
\series default
the reset of the components.
\end_layout

\begin_layout Standard
The frontend / backend separation reveals opportunities for distributed
 solutions of such a system, in case scalability becomes an issue.
\end_layout

\begin_layout Subsection
Web User Interface
\end_layout

\begin_layout Standard
The 
\series bold
Web UI 
\series default
is the simplest of the components of 
\series bold
MathSemantifier.

\series default
 It is intended to be a lightweight solution that queries a server for the
 results of more computationally intensive tasks.
\end_layout

\begin_layout Standard
The interface consists of an input area, where 
\series bold
MathML 
\series default
needs to be inputted, and two options:
\end_layout

\begin_layout Enumerate
Semantify
\end_layout

\begin_layout Enumerate
Show Semantic Tree
\end_layout

\begin_layout Standard
Since the second option is technically more powerful that the first one,
 since it generates all the possibilities at once, it is perfect to demo
 the results the system can give.
\end_layout

\begin_layout Standard
A series of example in 
\series bold
MathML 
\series default
is provided to show how the number of produced parse trees scales when varying
 the length and complexity of the input.
\end_layout

\begin_layout Subsection
MMT Backend
\end_layout

\begin_layout Standard
The MMT Backend is a 
\series bold
Server Extension 
\series default
that is part of MMT.
 
\end_layout

\begin_layout Standard
It is the core of the system, that assembles the results from all the other
 parts together into 
\series bold
Semantic Trees.
\end_layout

\begin_layout Standard
Its subcomponents are discussed below.
\end_layout

\begin_layout Subsubsection
Context Free Grammar Generator
\end_layout

\begin_layout Standard
The Grammar Generator aggregates all the knowledge contained in the MMT
 Notations into one Context Free Grammar.
 The grammar is shaped into the normal form accepted by the Marpa Grammar
 Engine.
 To achieve this, the format used to store the notations in MMT is decomposed
 into CFG rules.
 Otherwise said, the tree-like structure of each formula, that is stored
 as nested applications of 
\series bold
MMT Markers 
\series default
(discussed previously) needs to be serialized into CFG rules.
\end_layout

\begin_layout Standard
This is done in several steps:
\end_layout

\begin_layout Enumerate
Break apart the 
\series bold
MMT Marker 
\series default
trees into level by level representations
\end_layout

\begin_layout Enumerate
Transform the intermediate representation into valid CFG rules
\end_layout

\begin_layout Enumerate
Optimize if possible (will be discussed in detail in the subsequent sections)
\end_layout

\begin_layout Subsubsection
Semantic Tree Generator
\end_layout

\begin_layout Standard
The 
\series bold
Semantic Tree Generator 
\series default
works by recursively querying the 
\series bold
Parsing Backend 
\series default
and using the result to construct a the tree of possible meanings.
\end_layout

\begin_layout Standard
The parse trees stored in MMT have the following structure:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename parseTreeStructure.png
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Semantic Parse Tree Structure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:8}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This simple structure shown in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
autoref{fig:8}
\end_layout

\end_inset

 allows for a flexible way of parse tree storage.
 
\end_layout

\begin_layout Itemize

\series bold
Variants - 
\series default
represents a list of possible readings.
 It is always be the top node in any parse tree.
\end_layout

\begin_layout Itemize

\series bold
Notation - 
\series default
a notation detected in the input.
 It contains its name and arguments.
\end_layout

\begin_layout Itemize

\series bold
Argument - 
\series default
an argument of a notation.
 The plugin is recursively called on it to construct its meaning subtree
 as well.
\end_layout

\begin_layout Itemize

\series bold
RawString - 
\series default
the ground term representation
\end_layout

\begin_layout Standard
This structure is important because, in case another application wants to
 access the parse trees and process them, this structure will need to be
 dealt with.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
Content MathML Generator
\end_layout

\begin_layout Standard
The final part of any of the semantification processes is converting the
 internal represenation to a standard one, which is CMML in this case.
 MMT provides a simple API which requires:
\end_layout

\begin_layout Enumerate
The notation path
\end_layout

\begin_layout Enumerate
The argument maps
\end_layout

\begin_layout Standard
Both of which are available in my representation structure.
 The argument path is obtained by extacting the argument number from the
 argument name, and looking up in a map of paths created at the time of
 grammar creation.
 This implies the grammar rule names are overloaded with meaning, however,
 the possibilities are very limited in this aspect since the parsing framework
 used does not give complete control over the parsing process.
\end_layout

\begin_layout Subsection
Parsing Backend
\end_layout

\begin_layout Standard
The parsing backend consists of two parts.
 
\end_layout

\begin_layout Subsubsection
Context Free Grammar Parser
\end_layout

\begin_layout Standard
First of all, the the CFG needs to be queried and parsed.
 This is implemented using lazy evaluation, which means that it is only
 done when a request actually comes.
\end_layout

\begin_layout Standard
The serialized CFG is unpacked and feed to the Marpa Parser Generator.
\end_layout

\begin_layout Subsubsection
Parse Tree Generator
\end_layout

\begin_layout Standard
The more complex of the two parts is actually going throught the parse trees
 and extracting useful information.
 Note that going through all the parse trees is not practical, so only the
 first 
\begin_inset Formula $N$
\end_inset

 (currently 
\begin_inset Formula $1000$
\end_inset

) parse trees are processed.
 This still gives the correct results in most cases since the grammar rules
 are optimized for giving preference to parse trees that are more likely
 to be correct (discussed in more detail in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[6]{section 6}
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsection
Encoding issues
\end_layout

\begin_layout Standard
Since 
\series bold
MathSemantifier 
\series default
deals with unicode, and has parts written in Javascript, Scala and Perl,
 which treat unicode symbols differently, it needed a solution for this
 problem.
 Javascript and Scala have 
\series bold
UTF-16 
\series default
strings, while Perl has 
\series bold
UTF-8 
\series default
strings.
 The implemented solution simply passes around the string encoded using
 
\series bold
encodeURIComponent 
\series default
in Javascript or its equivalents in other languages, and only the parsing
 backend in Perl actually deals meaningfuly with substrings.
 The result of the parsing backend contains the complete subtrings for the
 matched rules and arguments.
 This also represents an opportunity for improvement, since passing around
 positions in a string is more efficient that substrings.
\end_layout

\begin_layout Section
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{6}
\end_layout

\end_inset

Optimizations and Heuristics
\end_layout

\begin_layout Standard
This section describes the attempts made in order to deal with the overwhelming
 ambiguity of mathematical notations and produce actual results.
 
\end_layout

\begin_layout Enumerate
Only notations on the whole input are matched.
 Subterms are matched directly by the 
\series bold
Semantic Tree 
\series default
plugin.
\end_layout

\begin_layout Enumerate
The number of parse trees is limited to 
\begin_inset Formula $N=1000$
\end_inset

.
 The number of parse trees was empirically determined to include the set
 of correct parses for the examples used (see the 
\series bold
Evaluation 
\series default
section
\series bold
).
\end_layout

\begin_layout Enumerate
The non-empty alternatives in the CFG are put first.
 The Grammar Parser has a predictable behaviour of going through the alternative
s left to right, and since empty rules match 
\series bold
always
\series default
, it is imperative that other alternative are attempted first.
 Note that only after this optimization any kind of results were possible
 to achieve on non-trivial input.
\end_layout

\begin_layout Enumerate
The CFG includes precedences correctly.
 This weeds out a large number of incorrect readings.
\end_layout

\begin_layout Enumerate
Sub-term sharing is part of the 
\series bold
MathML 
\series default
standard, and within one request, if sub-term sharing is enabled, the response
 tries to share its terms as much as possible in order to compress the output.
\end_layout

\begin_layout Enumerate

\series bold
The Semantic Tree 
\series default
plugin makes use of memoziation to reduce one dimension of the exponential
 blowup as explained on the following example.
 
\series bold

\begin_inset Formula $2+3$
\end_inset

 
\series default
has 6 possible readings, because 
\begin_inset Formula $+$
\end_inset

 is defined 6 times, between natural, integer, real numbers and so on.
 However, 
\begin_inset Formula $2$
\end_inset

 and 
\begin_inset Formula $3$
\end_inset

 - these subterms do not contain any notations, yet, the plugin needs to
 know that for every possibility of 
\begin_inset Formula $+$
\end_inset

.
 Memoization allows to omit a large number of 
\series bold
POST 
\series default
requests even in this simple example, which results into a signficant speedup
 of a factor of approximately 4 (13 
\series bold
POST
\series default
 requests vs 3 
\series bold
POST 
\series default
requests).
 Also, slight modification of the input benefit of a signifcant speed-up,
 as well as using a previous input as a subterm in a new input.
\end_layout

\begin_layout Section
Further work
\end_layout

\begin_layout Standard
The study presented in this paper reached certain results, however there
 is a long way yet to a fully automatic and scalable system that could handle
 large collections of papers without any supervision.
 Below there are some suggestions that further research could make use of
 in order to get closer to this goal.
\end_layout

\begin_layout Subsection
Suggestions for further optimizations
\end_layout

\begin_layout Enumerate
The CFG could be checked for unused rules, and, more importantly, converted
 to BNF, for instance
\end_layout

\begin_layout Enumerate
Theory based optimization - either let the user specify which theories to
 create the grammar from, or take into consideration that notations from
 the same theory are likely to be close in the input (for instance, 
\begin_inset Formula $-$
\end_inset

 and 
\begin_inset Formula $+$
\end_inset

 are more likely to both be used as arithmetic sybmols in an expression,
 than only one of them)
\end_layout

\begin_layout Enumerate
Sequence arguments (for instance, 
\begin_inset Formula $2+3+4+5+6$
\end_inset

) currently generate a very high number of possible parses.
 If more control over parsing were possible, parsing of sequence arguments
 should be greedy - attempting to take in as many delimiter argument pairs
 as there are.
\end_layout

\begin_layout Subsection
Requirements for a more suitable Notation Database 
\end_layout

\begin_layout Enumerate
The most important optimization would be adding types to the notation input
 arguments and output.
 This would allow for type based parsing, which would certainly be more
 efficient and generate more relevant results.
\end_layout

\begin_layout Enumerate
Grouping similar notations within a theory.
 For example, arithmetic plus on natural, integer or real number should
 be possible to connect somehow.
 If the notations have types, the it will naturally occur by grouping the
 notations with the same types into single rules.
\end_layout

\begin_layout Enumerate
For the 
\series bold
csymbol 
\series default
used in an 
\series bold
apply 
\series default
tag, the notation should cross-reference it with the part of the representation
 it corresponds to, since it is not otherwise clearly specified.
\end_layout

\begin_layout Subsection
Requirements for a more suitable Parsing Framework
\end_layout

\begin_layout Enumerate
One of the biggest problems with the current implementation is that it greedily
 matches the argument renderings, which are free form subterms.
 If a custom parsing framework would be used, lazy matching of such subterms
 would greatly increase the performance.
\end_layout

\begin_layout Enumerate
The ability to handle types, precedences and associativity.
\end_layout

\begin_layout Enumerate
The ability to handle greedy parsing - most CFG parsing frameworks have
 the counted rule 
\begin_inset Formula $Expression::=Expression+$
\end_inset

, which has a similar meaning to the 
\begin_inset Formula $+$
\end_inset

 found in a 
\series bold
regex.
 
\series default
However, 
\series bold
regexes
\series default
 actually will do a greedy match, the more appropriate match being then
 
\begin_inset Formula $Expression+?$
\end_inset

, the non-greedy version.
 This is critical to reduce the number of useless parse trees when dealing
 with Sequence Arguments
\end_layout

\begin_layout Section
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{8}
\end_layout

\end_inset

Evaluation 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ednote{The glossary needs to be fixed to some extend before I can do a proper
 evaluation}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This section presents an evaluation of 
\series bold
MathSemantifier 
\series default
from the point of view of how effective and efficient both guided semantificatio
n and semantic tree generation are.
 Next, the interoperability of the system with other possible applications
 is examined, which mostly depends on the backend APIs.
\end_layout

\begin_layout Subsection
Guided semantification
\end_layout

\begin_layout Standard
The user interface for top level symbol guided semantification is simple
 and intuitive, and it detects all the possible readings for the listed
 examples.
\end_layout

\begin_layout Subsection
Semantic Tree Generation
\end_layout

\begin_layout Standard
For the provided list of examples of depth 2-3, all the possible parse trees
 are produced.
\end_layout

\begin_layout Subsection
Performance of the Semantic Tree Generation
\end_layout

\begin_layout Standard
It is important to note that there are two kinds of figures we may want
 to look at: one run or several subsequent related runs.
 Because of memoization, in the long run, if the terms or evens just subterms
 repeat, the queries become signficantly faster.
 
\end_layout

\begin_layout Subsection
The backend APIs
\end_layout

\begin_layout Standard
It is important that the MMT backend provides a simple 
\series bold
HTTP 
\series default
endpoint, which can be accessed with a 
\series bold
POST
\series default
 request that contains just the input in a suitable encoding.
 The backend then returns a 
\series bold
JSON 
\series default
object that contains all the possible readings.
 The backend could be modified to accept parameters to fine tune the system,
 like the maximum number of processed parse trees, but even then accessing
 it would be just as simple.
 
\end_layout

\begin_layout Section
Conclusions 
\end_layout

\begin_layout Standard
The conclusion of this study is the proof of concept architecture and implementa
tion of a system capable of converting 
\series bold
Presentation MathML
\series default
 to all the possible meanings, which is a list of 
\series bold
Content MathML
\series default
.
 The testing revealed that the system is able to recognize correctly single
 top level symbols, as well as the whole set of readings of expressions
 of nesting depth up to 3 (this is not the limit, but not enough testing
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[8]{section 8}
\end_layout

\end_inset

 is done beyond that).
 This shows that it is certainly possible to aggregate the knowledge from
 the MMT Notations and to use it for parsing purposes.
 However, both the Notations and the Parsing Framework need significant
 improvements in order for the system to be scalable beyond what is presented
 in the previous section.
 The most important part of this study is, therefore, the optimizations
 and heuristics used, and other ones that further research could benefit
 from.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "bibtexDatabase"
options "bibtotoc,alpha-fr"

\end_inset


\end_layout

\end_body
\end_document
